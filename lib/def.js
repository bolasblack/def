// Generated by CoffeeScript 1.3.3
(function() {
  var __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty;

  (function(definition) {
    if (typeof define === "function") {
      return define(definition);
    } else if (typeof YUI === "function") {
      return YUI.add("", definition);
    } else {
      return definition();
    }
  })(function() {
    /*
      def prop, className, propName
      def fn, "judge", className
      def obj [, context, varname] [, tmpExtraMap]
    */

    var bindToContext, className, classes, def, extend, extendObj, extension, isType, method, olddef, regExtend, regJudge, typeJudge, underscoreArrayFns, _fn, _i, _j, _len, _len1, _ref, _results;
    def = function() {
      var args, fn, k, obj, _ref, _ref1;
      obj = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (obj == null) {
        throw new Error('must pass in an object');
      }
      if ((_ref = args.length) === 0 || _ref === 1) {
        return extendObj(obj, args[0]);
      }
      fn = args[0] === "judge" ? regJudge : (_ref1 = args[0], __indexOf.call((function() {
        var _results;
        _results = [];
        for (k in typeJudge) {
          if (!__hasProp.call(typeJudge, k)) continue;
          _results.push(k);
        }
        return _results;
      })(), _ref1) >= 0) ? regExtend(args[0]) : (extendObj(obj, args[3]), bindToContext(args[0]));
      fn(obj, args[1]);
      return obj;
    };
    def.isType = isType = function(type, obj) {
      return typeJudge[type](obj);
    };
    def._typeJudge = typeJudge = {};
    regJudge = function(judge, className) {
      return typeJudge[className] = judge;
    };
    def._extension = extension = {};
    regExtend = function(className) {
      return function(prop, propName) {
        var _base;
        extension[className] || (extension[className] = {});
        return (_base = extension[className])[propName] || (_base[propName] = prop);
      };
    };
    bindToContext = function(context) {
      return function(obj, varname) {
        return context[varname] = obj;
      };
    };
    extend = function(obj, extension) {
      var className, prop, propData, propName;
      for (className in extension) {
        propData = extension[className];
        if (!(isType(className, obj))) {
          continue;
        }
        obj.defed = true;
        for (propName in propData) {
          prop = propData[propName];
          obj[propName] = prop;
        }
      }
      return obj;
    };
    extendObj = function(obj, extraMap) {
      extend(obj, extension);
      if (extraMap) {
        extend(obj, extraMap);
      }
      return obj;
    };
    olddef = this.def;
    this.def = def;
    classes = "PlainObject Boolean Array Function String Number Date RegExp".split(" ");
    _ref = classes.concat(["Node", "XMLDoc", "Element"]);
    _fn = function(className) {
      return def(function(obj) {
        return G["is" + className](obj);
      }, "judge", className);
    };
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      className = _ref[_i];
      _fn(className);
    }
    if (typeof _ !== "undefined" && _ !== null ? typeof _.chain === "function" ? _.chain() : void 0 : void 0) {
      underscoreArrayFns = "first initial last rest compact flatten without union intersection difference uniq zip object range".split(" ");
      _results = [];
      for (_j = 0, _len1 = underscoreArrayFns.length; _j < _len1; _j++) {
        method = underscoreArrayFns[_j];
        _results.push(def(_[method], "Array", method));
      }
      return _results;
    }
  });

}).call(this);
