// Generated by CoffeeScript 1.3.3
(function() {

  (function() {
    var G, class2type, slice, toString, types;
    G = function(queryId) {
      return document.getElementById(queryId);
    };
    if (typeof define === "function" && define.amd) {
      define(function() {
        return G;
      });
    } else if (typeof exports !== "undefined" && exports !== null) {
      if ((typeof module !== "undefined" && module !== null) && module.exports) {
        module.exports = G;
      } else {
        exports.G = G;
      }
    } else {
      if (this.G != null) {
        G.old = this.G;
      }
      this.G = G;
    }
    slice = Array.prototype.slice;
    toString = Object.prototype.toString;
    G.extend = function() {
      var clone, copy, copyIsArray, deep, i, length, name, options, src, target, _i, _ref, _ref1;
      target = arguments[0] || {};
      length = arguments.length;
      deep = false;
      i = 1;
      if (this.isBoolean(target)) {
        deep = target;
        target = arguments[1];
        i = 2;
      }
      if (!(typeof target === "object" && this.isFunction(target))) {
        target = {};
      }
      if (length === i) {
        _ref = [this, i - 1], target = _ref[0], i = _ref[1];
      }
      for (i = _i = i, _ref1 = arguments.length; i <= _ref1 ? _i < _ref1 : _i > _ref1; i = i <= _ref1 ? ++_i : --_i) {
        if ((options = arguments[i]) != null) {
          for (name in options) {
            copy = options[name];
            if (!(target !== copy)) {
              continue;
            }
            src = target[name];
            if (deep && copy && (this.isPlainObject(copy) || (copyIsArray = this.isArray(copy)))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && (this.isArray(src) ? src : []);
              } else {
                clone = src && (this.isPlainObject(src) ? src : {});
              }
              target[name] = this.extend(deep, clone, copy);
            } else if (copy !== void 0) {
              target[name] = copy;
            }
          }
        }
      }
      return target;
    };
    class2type = {};
    types = 'Boolean Arguments Function String Number Date RegExp';
    types.replace(/[^, ]+/g, function(typeName) {
      class2type["[object " + typeName + "]"] = typeName.toLowerCase();
      return G["is" + typeName] = function(obj) {
        return toString.call(obj) === ("[object " + typeName + "]");
      };
    });
    if (!G.isArguments(arguments)) {
      G.isArguments = function(obj) {
        return !!(obj && G.has(obj, "callee"));
      };
    }
    if (typeof /./ !== 'function') {
      G.isFunction = function(obj) {
        return typeof obj === 'function';
      };
    }
    G.extend({
      toType: function(obj) {
        if (obj != null) {
          return class2type[toString.call(obj)] || "object";
        } else {
          return String(obj);
        }
      },
      isNode: function(obj) {
        return obj.nodeType != null;
      },
      isXMLDoc: function(obj) {
        var documentElement;
        documentElement = obj && (obj.ownerDocument || obj).documentElement;
        if (documentElement) {
          return documentElement.nodeName !== "HTML";
        } else {
          return false;
        }
      },
      isWindow: function(obj) {
        return (obj != null) && obj === obj.window;
      },
      isElement: function(obj) {
        return !!(obj && obj.nodeType === 1);
      },
      isPlainObject: function(obj) {
        var key;
        if (!obj || this.toType(obj) !== "object" || this.isNode(obj) || this.isWindow(obj)) {
          return false;
        }
        try {
          if (obj.constructor && !this.has(obj, "constructor") && !this.has(obj.constructor.prototype, "isPrototypeOf")) {
            return false;
          }
        } catch (e) {
          return false;
        }
        for (key in obj) {
          key;

        }
        return key === void 0 || this.has(obj, key);
      },
      isFinite: function(obj) {
        return isFinite(obj) && !isNaN(parseFloat(obj));
      },
      isObject: function(obj) {
        return obj === Object(obj);
      },
      isArray: Array.isArray || function(obj) {
        return toString.call(obj) === "[object Array]";
      },
      isBoolean: function(obj) {
        return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
      },
      isNaN: function(obj) {
        return obj !== obj;
      },
      isNull: function(obj) {
        return obj === null;
      },
      isUndefined: function(obj) {
        return obj === void 0;
      },
      isEmpty: function(obj) {
        var key;
        if (obj == null) {
          return true;
        }
        if (this.isArray(obj) || this.isString(obj)) {
          return obj.length === 0;
        }
        for (key in obj) {
          if (this.has(obj, key)) {
            return false;
          }
        }
        return true;
      }
    });
    return G.extend({
      has: function(obj, attr) {
        return Object.prototype.hasOwnProperty.call(obj, attr);
      },
      toArray: function(obj) {
        var k, v, _results;
        if (!obj) {
          return [];
        }
        if ((obj.toArray != null) && this.isFunction(obj.toArray)) {
          return obj.toArray();
        }
        if (obj.length === obj.length) {
          return slice.call(obj);
        }
        _results = [];
        for (k in obj) {
          v = obj[k];
          _results.push(v);
        }
        return _results;
      }
    });
  })();

}).call(this);
